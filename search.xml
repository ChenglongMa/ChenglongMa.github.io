<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式总结]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[¶前言 本文旨在帮助复习设计模式相关概念，只包含简略要点，非详细介绍。 ¶设计模式类型 ¶创建型 Creational Patterns (5): ​ abstract the object instantiation process. 工厂方法模式 factory 抽象工厂 abstractFactory 单例模式 singleton 建造者模式 builder 原型模式 prototype ¶结构型 Structural Patterns (7): ​ describe how classes and objects can be combined to form larger structures. 桥接模式bridge 适配器模式adapter 装饰器模式decorator 组合模式composite 享元模式flyweight 外观模式facade 代理模式proxy ¶行为型 Behavioural Patterns (11): ​ are most specifically concerned with communication between objects. 模板方法模式template 策略模式strategy 两个类之间: 观察者模式observer 迭代子模式iterator（容器与容器遍历） 责任链模式chain of responsibility（责任链模式）（串的替换—可以使用链式操作） 命令模式command 类的状态： 备忘录模式memento 状态模式state 通过中间类： 访问者模式visitor 中介模式mediator 解释器模式interpreter ¶Adapter 适配器模式 ¶类图： ¶代码示例： 原有程序代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Context &#123; public static void main(String[] args) &#123; // 这里只是提供一种应用场景， // 并非必须要 switch 或者 for loop oldTest(); newTest(); &#125; /** * Adapter 版调用方式 */ static void newTest() &#123; IShapeAdapter[] shapes = &#123; new ILineAdapter(), new IRectangleAdapter(), new IWeatherMapAdapter() &#125;; // A begin and end point from a graphical editor Point p1 = new Point(10, 20); Point p2 = new Point(30, 60); for (IShapeAdapter shape : shapes) &#123; // 统一了调用方法签名 shape.draw(p1, p2); &#125; &#125; /** * 原版调用方式 */ static void oldTest() &#123; Object[] shapes = &#123;new LineGraphic(), new RectangleGraphic()&#125;; // A begin and end point from a graphical editor Point p1 = new Point(10, 20); Point p2 = new Point(30, 60); for (Object shape : shapes) if (shape.getClass().getName().equals("Line")) ((LineGraphic) shape).drawLine(p1, p2); else if (shape.getClass().getName().equals("Rectangle")) ((RectangleGraphic) shape).drawRect( new Point(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)), Math.abs(p2.x - p1.x), Math.abs(p2.y - p1.y) ); &#125; static class LineGraphic &#123; void drawLine(Point p1, Point p2) &#123; // Stub for testing replacing real library call System.out.println("line from " + p1 + " to " + p2); &#125; &#125; static class RectangleGraphic &#123; void drawRect(Point p, int width, int height) &#123; // Stub for testing replacing real library call System.out.println("rectangle at " + p + " with width " + width + " and height " + height); &#125; &#125; static class WeatherMapGraphic &#123; void drawCurrent(int length, Point p) &#123; System.out.println("WeatherMapGraphic drawCurrent was called"); &#125; &#125;&#125; 以下为新增类 123456// Adapter 接口// 1. 统一方法签名// 2. 为可能的新增功能提供接口规范public interface IShapeAdapter &#123; void draw(Point p1, Point p2);&#125; 各个Adapter中存在参数类型转换以适应新接口 12345678class ILineAdapter implements IShapeAdapter &#123; private Context.LineGraphic adaptee = new Context.LineGraphic(); @Override public void draw(Point p1, Point p2) &#123; adaptee.drawLine(p1, p2); &#125;&#125; 123456789class IRectangleAdapter implements IShapeAdapter &#123; private Context.RectangleGraphic adaptee = new Context.RectangleGraphic(); @Override public void draw(Point p1, Point p2) &#123; adaptee.drawRect(new Point(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)), Math.abs(p2.x - p1.x), Math.abs(p2.y - p1.y)); &#125;&#125; 12345678910class IWeatherMapAdapter implements IShapeAdapter &#123; private Context.WeatherMapGraphic adaptee = new Context.WeatherMapGraphic(); @Override public void draw(Point p1, Point p2) &#123; int length = Math.abs(p2.x - p1.x); Point p = new Point(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)); adaptee.drawCurrent(length, p); &#125;&#125; ¶关键词: incompatible, different interfaces, different methods (method signature) ¶总结 当出现以上关键词或者在Class Diagram里各个相似的类，方法名或方法签名（签名包括方法名和参数列表）不同时，应该使用Adapter pattern。 ¶Factory (not GoF) 简单工厂模式 ¶代码示例： 123public interface IShape &#123; void draw();&#125; 1234567891011121314151617181920public class Circle implements IShape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125;public class Rectangle implements IShape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125;public class Square implements IShape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 12345678910111213141516public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public IShape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 1234567891011121314151617public class Context &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 IShape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 IShape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 IShape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; Output: Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. ¶关键词： complex creation logic, separate the creation responsibilities for better cohesion ¶总结 简单工厂模式(Simple Factory) 是对GoF中工厂模式的简化，二者不是同一模式 工厂模式隐藏了创建细节，特别是复杂的创建过程 ¶Singleton (单例模式) ¶类图： ¶代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 以 &#123;@link ShapeFactory&#125; 为例 */public class SingletonShapeFactory extends ShapeFactory &#123; /** * NOTE： * 该变量为 private static * 用于内部实例化该类 */ private static SingletonShapeFactory instance = new SingletonShapeFactory(); /** * NOTE： * 构造函数访问符一定为 private * 目的是阻止外界访问，阻止外界实例化 * 这样该类在整个程序中只有一个实例化过的对象 * 即 instance */ private SingletonShapeFactory() &#123; // do sth... &#125; /** * 提供 static 方法，为外界提供访问入口 * * @return 唯一的 instance */ public static SingletonShapeFactory getInstance() &#123; return instance; &#125; /** * 单例模式的变种之一 * 1. Lazy initialization * instance初始值为 null * 即 instance 只在需要时被实例化 * 2. 使用 synchronized 修饰 * 防止多线程并发访问时造成实例化多个 instance * * @return */ public static synchronized SingletonShapeFactory getInstance2() &#123; if (instance == null) instance = new SingletonShapeFactory(); return instance; &#125;&#125; ¶关键词： one instance of a class is allowed, Objects need a global and single point of access ¶总结 要点： private constructor static instance and getter 在class diagram或sequence diagram中类名右上角标注1 思考： 如果getInstance()方法替换为以下代码行不行； 1234public static SingletonShapeFactory getInstance() &#123; // 同样保证了外界无法 new 另外的对象 return new SingletonShapeFactory();&#125; Why not aren’t all Singleton service methods static? static 方法不能被Override，不是虚方法，所以无法实现多态(not polymorphic) ¶Strategy (策略模式) ¶类图： ¶总结 要点： 使用哪种策略的判断条件不尽相同，自定义 即，Lecture Note中将 Context Object Sale作为参数传入ISalePricingStrategy中不是唯一/必须的 执行策略模式的方法一般是将策略接口作为参数传入，例如： 123public int executeStrategy(IStrategy stragtegy, int num1, int num2,...)&#123; return strategy.doOperation(num1, num2,...);&#125; 策略模式视不同情况执行不同策略，而不是 同时 执行 所有 策略，所以不一定要有 if…else…或switch…case… ¶Composite (组合模式) ¶类图： ¶代码示例： 123456/** * Pricing Strategy 接口 */public interface ISalePricingStrategy &#123; Money getTotal(SaleContext saleContext);&#125; 12345678910111213141516/** * 普通策略 */public class AbsoluteDiscountOverThresholdPricingStrategy implements ISalePricingStrategy &#123; private Money discount, threshold; public AbsoluteDiscountOverThresholdPricingStrategy(Money discount, Money threshold) &#123; this.discount = discount; this.threshold = threshold; &#125; @Override public Money getTotal(SaleContext saleContext) &#123; return new Money(discount.yuan * 0.01 + threshold.yuan); &#125;&#125; 123456789101112131415/** * 普通策略 */public class PercentageDiscountPricingStrategy implements ISalePricingStrategy &#123; private double percentage; public PercentageDiscountPricingStrategy(double percentage) &#123; this.percentage = percentage; &#125; @Override public Money getTotal(SaleContext saleContext) &#123; return new Money(saleContext.getPreDiscountTotal() * percentage); &#125;&#125; 12345678910111213/** * 策略模式 + 组合模式 (abstract class) */public abstract class CompositePricingStrategy implements ISalePricingStrategy &#123; protected List&lt;ISalePricingStrategy&gt; pricingStrategies = new ArrayList&lt;&gt;(); public void add(ISalePricingStrategy strategy) &#123; pricingStrategies.add(strategy); &#125; @Override public abstract Money getTotal(SaleContext saleContext);&#125; 1234567891011121314151617/** * 如果要求写代码 * 注意 interface 用 implements //第三人称 * abstract class 用 extends //第三人称 */public class CompositeBestForCustomerPricingStrategy extends CompositePricingStrategy &#123; @Override public Money getTotal(SaleContext saleContext) &#123; double lowestTotal = Double.MAX_VALUE; for (ISalePricingStrategy strategy : pricingStrategies) &#123; double total = strategy.getTotal(saleContext).yuan; lowestTotal = Math.min(total, lowestTotal); &#125; return new Money(lowestTotal); &#125;&#125; 1234567public class CompositeBestForStorePricingStrategy extends CompositePricingStrategy &#123; @Override public Money getTotal(SaleContext saleContext) &#123; //TODO: do sth... return null; &#125;&#125; ¶关键词： group or composition ¶总结 要点： CompositePricingStrategy 可以是具体类，也可以是抽象类 (abstract class) Composite class可以包含任意实现 Component 接口的类，包括自己 在 Composite 的 operation() 中可以 for...each 执行所有子类 operation()，也可以筛选特定执行 在 Composite + Strategy 的模式中，谨防将 CompositeStrategy 写成 Context ，区别在于 CompositeStrategy 可组合部分也可以组合全部策略，而 Context 必须适用全部策略 ¶Façade (外观模式) ¶类图： ¶代码示例： Subsystem代码： 1234567891011121314151617181920212223242526public class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; public class Memory &#123; public void startup()&#123; System.out.println("memory startup!"); &#125; public void turnoff()&#123; System.out.println("memory shutdown!"); &#125; &#125; public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void poweroff()&#123; System.out.println("disk shutdown!"); &#125; &#125; Facade 代码： 123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer() &#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup() &#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown() &#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.turnoff(); disk.poweroff(); System.out.println("computer closed!"); &#125;&#125; ¶关键词： common, unified interface, subsystem ¶总结 要点： 接口不是必需，因为不能要求subsystem中方法签名都必须相同 如：shutdown() / turnoff() / poweroff() 该模式应用于将复杂的系统执行简化、隐藏细节 ¶Observer (aka Publish-Subscribe) (观察者模式) ¶类图： ¶关键词： subscriber or listener ¶总结 freestyle]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable和Mutable Objects in Java]]></title>
    <url>%2F2017%2F11%2F10%2FImmutable%E5%92%8CMutable-Objects-in-Java%2F</url>
    <content type="text"><![CDATA[¶前言 本文主要阐述以下观点： 值类型与引用类型的定义与区别； 不可变对象与可变对象的定义与区别； 不可变对象的优点与缺点； String类为什么是不可变的； 怎样声明不可变对象（包括变量和类）； ¶是什么？ 在了解不可变对象（Immutable Objects）及可变对象（Mutable Objects）之前，我们需要知道内存中两种数据类型：值类型（value types）和引用类型（reference types）—— 值类型数据存放在**栈（stack）**内，其值代表数据本身，存储在栈中分配的内存空间。 引用类型数据存放在堆（heap）内，其值代表的是所指向的地址，指向所要存储的值而不直接存储。 例如：假设Person是一种值类型，House是一种引用类型，有以下变量： 1234Person 老王 = new Person(); //Person 是值类型Person 小王 = 老王； //小王是老王“克隆”出来的，一模一样；House 老王的家 = new House();//House 是引用类型House 小王的家 = 老王的家； //小王和老王住在同一个家里； 那么基于此，假如有一天老王因某事败露而被打残，小王的安危并不会受此影响，即使他们有相同的样貌，因为他们是相互独立的个体；而老王家里置办了新的电视或惨遭洗劫，“小王的家”自然也会接受相同的改变，因为他们家的地址指向了同一条街道的同一个房间。 在Java中，只有基本类型（Primitive Data Types）（即byte, short, int, long, float, double, char, boolean）是值类型，其他的数据类型都是引用类型，包括String，即对象（Objects）. 而引用类型又分为不可变对象（Immutable Objects）和可变对象（Mutable Objects），可变对象即为上述提到的普通引用类型数据，如果两个变量指向同一地址时，其中一个的值改变了另一个值也同样改变，下面详细说一下对不可变对象的理解。 ¶Immutable Objects An object is considered immutable if its state cannot change after it is constructed.[1] 即：不可变对象在构造（声明并且初始化后）之后，其状态不可再改变。其中String类和基本类型的Wrapper Class （Integer, Double, etc.）属于典型的不可变类。这里需要注意：状态不可变是指对象实例的值不可变而不是指向该实例的引用的不可变，例如： 12String king= "John Snow";king = "others"; 上述所示好像String 的值发生了改变，说好的String 一生不变到白头，它却偷偷焗了油；其实，此处的不可变是指&quot;John Snow&quot;这个内存中的值没有发生变化，只是king不再指向它了，而换成了&quot;others&quot;，那么&quot;John Snow&quot;去哪儿了？~~长城之外还是龙妈闺房？~~很可惜，都不是，他被留在了内存里，等待GC（Garbage Collection，垃圾收集，垃圾回收）来回收他。 那这样做有什么好处？白白制造出了内存垃圾，king到头来还是易主了？ ¶为什么？ 首先，我们知道String是不可变类，而StringBuilder是可变的，所以先看代码： 123456789101112131415161718192021public static void main(String args[]) &#123; String John = "John"; StringBuilder John2 = new StringBuilder("John"); System.out.println("What's your name?\t" + John); System.out.println("Your full name please.\t" + getFullName(John)); System.out.println("What's your first name?\t" + John); System.out.println(); System.out.println("What's your name?\t" + John2); System.out.println("Your full name please.\t" + getFullName(John2)); System.out.println("What's your first name?\t" + John2);&#125;private static String getFullName(String fstName) &#123; fstName += " Snow"; return fstName;&#125;private static StringBuilder getFullName(StringBuilder fstName) &#123; fstName.append(" Snow"); return fstName;&#125; 执行结果如下： 1234567// What's your name? John// Your full name please. John Snow// What's your first name? John //Value has NOT changed.// What's your name? John// Your full name please. John Snow// What's your first name? John Snow //Value has changed. 上述所示，可变类StringBuilder的值改变了，而这常常不是程序员想要或主动要做的，所以不可变类的一大优点是保证了线程安全，不会出现同步问题和隐私泄漏（Privacy Leaks）。当然，这种隐患还可以通过保护性拷贝（Defensive Copy）或深度复制（Deep Copy）来规避，不可变类同样可靠，但代码简单。 除此之外，不可变类还提高了拷贝的效率，因为复制时不再需要复制该对象的值，只需要复制其地址（指针）即可，而这只需要很小的内存空间，同时，对其他引用该对象的变量不造成影响。[2] 由开始时&quot;John Snow&quot;被“雪藏”的例子可以看出，过多的不可变类会造成很多内存垃圾，一定程度上增加了程序的运行成本，但也有不同看法认为： 程序员往往不愿使用不可变对象，因为他们担心创建一个新的对象要比更新对象的成本要高。实际上这种开销常常被过分高估，而且使用不可变对象所带来的一些效率提升也抵消了这种开销。例如：使用不可变对象降低了垃圾回收所产生的额外开销，也减少了用来确保使用可变对象不出现并发错误的一些额外代码。[3] 所以一般更多地建议在代码中合理运用不可变类。 ¶怎么做？ 局部变量、成员变量和类都可以声明为不可变对象。局部变量、成品变量操作较为简单，归为一类，不可变类单说。 ¶不可变变量 形式： 1(vis) final type var = value; 例如： 局部变量：final String king = &quot;John Snow&quot;; 成员变量：private final String king = &quot;John Snow&quot;; 特殊地，常量以以下形式声明： public static final String KING = &quot;John Snow&quot;; 特别需要注意数组（Array）等类型的不可变性： 12345678final String[] week = new String[]&#123;"Sunday", "Monday", "Tuesday", "Wednesday"...&#125;;//Week = new String[]&#123;"Sunday", "Sunday", "Sunday", "Sunday"...&#125;; //invalidfor (int i = 0; i &lt; week.length; i++) &#123; week[i] = "Sunday";&#125;System.out.println(Arrays.toString(week)); 执行结果如下： 1//[Sunday, Sunday, Sunday, Sunday, Sunday, Sunday, Sunday] 上述代码中，将数组变量week置为不可变，那么当我们要将一周的每一天都赋值为星期天时，它如约提示&quot;Cannot assign a value to final variable&quot; 让我们断了念想，但转身一个for 循环就实现了，在使用中要注意这种情况。 ¶不可变类 不可变类的声明要麻烦很多，不单单是声明为&quot;final&quot;就可以的，而且，&quot;final&quot;在不可变类中的作用是使该类不可被继承，而和使之不可变没有必然联系。主要步骤如下： 保证所有成员变量必须私有（private），并且用final修饰 不提供改变成员变量的方法，包括setter 通过构造器初始化所有成员，进行深拷贝(deep copy)，特别是对非基本类型的成员，即引用类型 类添加final修饰符，保证类不被继承 看一下Java自己源代码中不可变类（String）是如何定义的： 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 ... &#125; String 类中基本符合以上声明的主要步骤； 可以看到String其实是用char[]存储数据的，但它是final 并且private的，所以避免了像week数组那样被改写的风险； 有个hash变量没有final，这里利用了其他的机制来保证其不可变，这里不做解释，可以参考： 如何理解String类型值的不可变？ - Halty的回答 - 知乎 Java中同样有没有将类声明为final的不可变类（BigDecimal和BigInteger），如下代码： 123456789public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; &#123; /** * The unscaled value of this BigDecimal, as returned by &#123;@link * #unscaledValue&#125;. * * @serial * @see #unscaledValue */ private final BigInteger intVal; 但同样采取了其他机制来保证其不可变性。 ¶总结 本文简单介绍了Immutable Objects（不可变对象）和Mutable Objects（可变对象）的一些特点，合理运用不可变对象会使代码整洁而高效，特别是在事件、多线程等数据安全性要求高的情景下，在实践中可以摸索出适合自己的代码风格。 ¶参考文献 https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html ↩ http://zhiheng.me/124#comment-195 ↩ https://waylau.gitbooks.io/essential-java/docs/concurrency-Immutable Objects.html# ↩]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Immutable</tag>
        <tag>Mutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JAVA抽象类及接口]]></title>
    <url>%2F2017%2F10%2F11%2F%E6%B5%85%E8%B0%88JAVA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[作为面向对象语言，JAVA同样具有封装、继承和多态的基本特征，其中抽象类和接口很好地体现了这一点，因为结构相似但又有实际的不同，所以这里放在一起说。 假如我们要写一个Zoo的project，有多种动物的类Dog, Cat, Parrot等，它们都有eat()的方法，我们会自然想到建造一个Animal的类作为父类存放这些动物共有的方法及属性，如下： 12345678910111213public class Animal &#123; public void eat(String food) &#123; System.out.println("I am eating " + food); &#125;&#125;public class Dog extends Animal &#123;&#125;---------------------------------------------------- 应用时： Animal Snoopy=new Dog(); Snoopy.eat("Cookies"); 我们发现即使不用抽象类也可以很好地完成任务，那么为什么要用抽象类而不用普通类呢？ 先从抽象方法讲起： ¶抽象方法 抽象方法指用“abstract” 修饰的方法，该方法只有声明，没有实现的方法体，它的具体实现交给子类来确定，可以看出抽象方法是生而为“继承”的，例如在Animal中只指定eat()方法，具体怎么吃让小狗小猫去决定： 1abstract void eat(String food); 使用抽象方法有三点要求： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 构造方法及静态方法（类方法，用static修饰）不能声明为抽象方法，也无法对其进行重写Override。 那么问题的答案很明了了，当Animal中有抽象方法时，那么使用普通类就不行了，必须使用抽象类，那么类里没有抽象方法，可不可以声明为抽象类呢？有何作用？ ¶抽象类 抽象类是对**对象（类）**的抽象，和抽象方法一样，声明抽象类时只需要使用修饰符“abstract” 就可以： 12345public abstract class Animal &#123; abstract void eat(String food);&#125; 抽象方法必须包含在抽象类里，但抽象类里不一定要有抽象方法 先回答前一个小问题，没有抽象方法，类一样可以声明为抽象类，和普通类除了修饰符其余写法一样 抽象类只能被继承，不可以实例化 很好理解，抽象类作为抽象出来的“模具”存在，自然不能“实例化”，只有抽象类的非抽象子类可以创建对象。第二个小问题答案也就有了，没有抽象方法的抽象类的作用是：强制子类去继承该类，并强制不允许被实例化。基于此，人们通常在设计阶段决定要不要设计抽象类。 抽象类可以有无数子类，但一个子类只能继承一个抽象类 这个和普通类相同，子类只允许有一个父类。注意区分接口：子类可以实现多个接口。 抽象类可以继承别的抽象类，可以实现别的接口 抽象类可以有构造函数，只是是为子类提供的 抽象类内构造函数是要求子函数必须实现的，所以在子类的构造函数中必须加一句 super(); 1234567891011public class Dog extends Animal &#123; public Dog() &#123; super(); &#125; @Override public void eat(String food) &#123; //do something &#125;&#125; ​ 我们了解到还有一种不能实例化也没有方法具体实现的机制，接口，那和抽象类有什么区别？ ¶接口 接口是对对象行为的抽象，通常以interface来声明，是抽象方法的集合。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 1234567891011public interface Movable &#123; //这里省略public static final，因为接口里变量 //默认都是常量，而且不能private /*public static final*/ String name = null; //这里省略public abstract，因为接口里方法默认都是抽象的，符合 //抽象方法的一切特点 /*public abstract*/ void walk(); void run();&#125; 如上图所示，接口内只能声明public常量和抽象方法 public static final 和 public abstract 可以省略 接口内没有构造函数 因为接口不能实例化，而且接口不是类，只是一类动作的集合，所以不存在“构造”的概念 接口不是被类继承(extends)了，而是要被类实现(implements)。 准确地说，接口不是类，所以不能被继承，它是方法的集合，可以被实现。（用法相似，称呼不同） 子类可以实现多个接口 这一点是与其他类最明显的差异，普通类及抽象类都只能单一继承 接口可以继承别的接口，但不能继承类 ​ ¶抽象类与接口的区别 抽象类是对对象的抽象；接口是对行为的抽象 虽然两者在使用的相似，甚至可以互换而不出现bug，但两者设计的初衷是不同的 抽象类是一类事物，像Animal对Dog； 接口是一类动作，像Movable对walk()； 抽象类单一继承；接口可以多“继承”（准确地应该是__实现__ ） 抽象类可以像普通类一样声明各类字段，各类方法；接口只能声明常量和抽象方法 抽象类可以实现包括抽象方法的其他任意方法； 接口只有常量和抽象方法（在最新的JAVA8中情况有所改变，本篇只点不讲） 接口内不能有构造函数而抽象类可以有； 基本区别就是这些，可以在日后的实践中慢慢掌握，目前来说必须掌握的是1.2.两条。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Abstract Class</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
</search>
